name: Slack Message Polling and Issue Creation

on:
  schedule:
    - cron: '*/3 * * * *'  # 3分毎に実行（リアルタイム性向上）

jobs:
  process-slack-messages:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
      id-token: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Get Slack Messages
        id: slack
        run: |
          # 5分前のタイムスタンプを計算
          oldest=$(date -d '5 minutes ago' +%s)
          
          # Slack APIでメッセージを取得
          curl -s -H "Authorization: Bearer ${{ secrets.SLACK_BOT_TOKEN }}" \
            "https://slack.com/api/conversations.history?channel=${{ secrets.SLACK_CHANNEL_ID }}&oldest=$oldest&limit=50" \
            > slack_response.json
          
          # レスポンスをチェック
          if [ "$(jq -r '.ok' slack_response.json)" = "true" ]; then
            echo "Slack API call successful"
            
            # 新しいメッセージをフィルタリング（ボットメッセージと処理済みを除外）
            FILTERED_MESSAGES=$(jq -c '[.messages[] | select(.bot_id == null and (.reactions // [] | any(.name == "white_check_mark") | not))]' slack_response.json)
            
            # メッセージが存在するかチェック
            if [ "$FILTERED_MESSAGES" != "[]" ] && [ "$FILTERED_MESSAGES" != "null" ]; then
              echo "Found new messages to process"
              echo "has_messages=true" >> $GITHUB_OUTPUT
              echo "messages=$FILTERED_MESSAGES" >> $GITHUB_OUTPUT
              echo "Messages output: $FILTERED_MESSAGES"
            else
              echo "No new messages found"
              echo "has_messages=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "Slack API Error: $(jq -r '.error' slack_response.json)"
            exit 1
          fi

      - name: Process Messages with Gemini
        if: steps.slack.outputs.has_messages == 'true'
        id: gemini_process
        run: |
          echo "Processing messages with Gemini API..."
          
          # Slackメッセージを取得
          MESSAGES='${{ steps.slack.outputs.messages }}'
          echo "Messages to process: $MESSAGES"
          
          # 各メッセージを処理
          echo "$MESSAGES" | jq -r '.[] | @base64' | while read -r encoded_msg; do
            msg=$(echo "$encoded_msg" | base64 -d)
            msg_text=$(echo "$msg" | jq -r '.text')
            msg_ts=$(echo "$msg" | jq -r '.ts')
            msg_user=$(echo "$msg" | jq -r '.user')
            
            echo "Processing message: $msg_text"
            
            # Gemini APIでメッセージを整形（構造化出力使用）
            GEMINI_RESPONSE=$(curl -s -X POST \
              -H "x-goog-api-key: ${{ secrets.GEMINI_API_KEY }}" \
              -H "Content-Type: application/json" \
              -d '{
                "contents": [{
                  "parts": [{
                    "text": "以下のSlackメッセージをGitHub Issue用のタイトルと本文に整形してください。雑談や質問の場合はshould_create_issueをfalseにしてください。また、内容の緊急度・重要度に応じて優先度を設定してください。\n\nSlackメッセージ: '$msg_text'"
                  }]
                }],
                "generationConfig": {
                  "responseMimeType": "application/json",
                  "responseSchema": {
                    "type": "OBJECT",
                    "properties": {
                      "title": {
                        "type": "STRING",
                        "description": "明確で具体的なタイトル"
                      },
                      "body": {
                        "type": "STRING", 
                        "description": "構造化された説明"
                      },
                      "should_create_issue": {
                        "type": "BOOLEAN",
                        "description": "Issueを作成するかどうか"
                      },
                      "priority": {
                        "type": "STRING",
                        "enum": ["low", "medium", "high", "urgent"],
                        "description": "優先度: low(低), medium(中), high(高), urgent(緊急)"
                      }
                    },
                    "required": ["title", "body", "should_create_issue", "priority"]
                  }
                }
              }' \
              "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent")
            
            if [ $? -eq 0 ]; then
              echo "Gemini API call successful"
              echo "Raw response: $GEMINI_RESPONSE"
              
              # 構造化出力から直接JSONを解析
              GEMINI_JSON=$(echo "$GEMINI_RESPONSE" | jq -r '.candidates[0].content.parts[0].text')
              echo "Gemini structured output: $GEMINI_JSON"
              
              # Issueを作成するかチェック
              if echo "$GEMINI_JSON" | jq -e '.should_create_issue' >/dev/null 2>&1; then
                SHOULD_CREATE=$(echo "$GEMINI_JSON" | jq -r '.should_create_issue')
                if [ "$SHOULD_CREATE" = "true" ]; then
                  ISSUE_TITLE=$(echo "$GEMINI_JSON" | jq -r '.title')
                  ISSUE_BODY=$(echo "$GEMINI_JSON" | jq -r '.body')
                  ISSUE_PRIORITY=$(echo "$GEMINI_JSON" | jq -r '.priority')
                  
                  echo "Creating issue with title: $ISSUE_TITLE (Priority: $ISSUE_PRIORITY)"
                  echo "issue_data<<EOF" >> $GITHUB_OUTPUT
                  echo "{\"title\": \"$ISSUE_TITLE\", \"body\": \"$ISSUE_BODY\", \"priority\": \"$ISSUE_PRIORITY\", \"user\": \"$msg_user\", \"ts\": \"$msg_ts\"}" >> $GITHUB_OUTPUT
                  echo "EOF" >> $GITHUB_OUTPUT
                  echo "should_create_issue=true" >> $GITHUB_OUTPUT
                else
                  echo "Skipping issue creation - determined to be casual conversation"
                fi
              else
                echo "Error: Could not parse Gemini structured output as JSON"
              fi
            else
              echo "Error: Gemini API call failed"
            fi
          done

      - name: Create Priority Labels
        if: steps.gemini_process.outputs.should_create_issue == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            // 優先度ラベルを事前作成（既存の場合はスキップ）
            const priorityLabels = [
              { name: 'Priority: Low', color: 'f1bc31', description: '低優先度のIssue' },
              { name: 'Priority: Medium', color: 'e88a1a', description: '中優先度のIssue' },
              { name: 'Priority: High', color: 'b22222', description: '高優先度のIssue' },
              { name: 'Priority: Critical', color: '7c0a02', description: '緊急対応が必要なIssue' }
            ];
            
            for (const label of priorityLabels) {
              try {
                await github.rest.issues.createLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: label.name,
                  color: label.color,
                  description: label.description
                });
                console.log(`Created label: ${label.name}`);
              } catch (error) {
                if (error.status === 422) {
                  console.log(`Label already exists: ${label.name}`);
                } else {
                  console.error(`Error creating label ${label.name}:`, error.message);
                }
              }
            }
            
            // from-slackとauto-createdラベルも作成
            const additionalLabels = [
              { name: 'from-slack', color: '4a154b', description: 'Slackから自動作成されたIssue' },
              { name: 'auto-created', color: '0366d6', description: '自動作成されたIssue' }
            ];
            
            for (const label of additionalLabels) {
              try {
                await github.rest.issues.createLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: label.name,
                  color: label.color,
                  description: label.description
                });
                console.log(`Created label: ${label.name}`);
              } catch (error) {
                if (error.status === 422) {
                  console.log(`Label already exists: ${label.name}`);
                } else {
                  console.error(`Error creating label ${label.name}:`, error.message);
                }
              }
            }

      - name: Create GitHub Issue
        if: steps.gemini_process.outputs.should_create_issue == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const issueData = JSON.parse('${{ steps.gemini_process.outputs.issue_data }}');
            
            // 優先度に応じたラベルを設定（一般的な命名規則に従う）
            const priorityLabels = {
              'urgent': ['Priority: Critical', 'from-slack', 'auto-created'],
              'high': ['Priority: High', 'from-slack', 'auto-created'],
              'medium': ['Priority: Medium', 'from-slack', 'auto-created'],
              'low': ['Priority: Low', 'from-slack', 'auto-created']
            };
            
            const labels = priorityLabels[issueData.priority] || ['from-slack', 'auto-created'];
            
            const issue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: issueData.title,
              body: `**優先度**: ${issueData.priority.toUpperCase()}\n\n${issueData.body}\n\n---\n*Originally posted in Slack by user ${issueData.user}*\n\n@claude`,
              labels: labels
            });
            
            console.log(`Created issue #${issue.data.number}: ${issue.data.html_url}`);
            core.setOutput('issue_number', issue.data.number);
            core.setOutput('issue_url', issue.data.html_url);
            
            // repository_dispatchでSlack専用Claudeワークフローをトリガー
            await github.rest.repos.createDispatchEvent({
              owner: context.repo.owner,
              repo: context.repo.repo,
              event_type: 'claude-trigger',
              client_payload: {
                issue_number: issue.data.number,
                issue_url: issue.data.html_url,
                trigger_type: 'new_issue_with_claude_mention'
              }
            });
            
            console.log(`Triggered Claude Slack Issues workflow for issue #${issue.data.number}`);

      - name: Mark Messages as Processed
        if: steps.slack.outputs.has_messages == 'true'
        run: |
          # 処理済みメッセージにリアクションを追加
          echo "Processing messages for reactions..."
          echo '${{ steps.slack.outputs.messages }}' | jq -r '.[] | .ts' | while read ts; do
            if [ -n "$ts" ]; then
              echo "Adding reaction to message: $ts"
              RESPONSE=$(curl -s -X POST \
                -H "Authorization: Bearer ${{ secrets.SLACK_BOT_TOKEN }}" \
                -H "Content-Type: application/json" \
                -d "{\"channel\": \"${{ secrets.SLACK_CHANNEL_ID }}\", \"timestamp\": \"$ts\", \"name\": \"white_check_mark\"}" \
                https://slack.com/api/reactions.add)
              
              # レスポンスをチェック
              if [ "$(echo "$RESPONSE" | jq -r '.ok')" = "true" ]; then
                echo "Successfully added reaction to $ts"
              else
                echo "Failed to add reaction to $ts: $(echo "$RESPONSE" | jq -r '.error')"
              fi
            fi
          done