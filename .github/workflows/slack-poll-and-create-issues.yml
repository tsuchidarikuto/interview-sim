name: Slack Message Polling and Issue Creation

on:
  schedule:
    - cron: '*/3 * * * *'  # 3分毎に実行（リアルタイム性向上）

jobs:
  process-slack-messages:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
      id-token: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Get Slack Messages
        id: slack
        run: |
          # 5分前のタイムスタンプを計算
          oldest=$(date -d '5 minutes ago' +%s)
          
          # Slack APIでメッセージを取得
          curl -s -H "Authorization: Bearer ${{ secrets.SLACK_BOT_TOKEN }}" \
            "https://slack.com/api/conversations.history?channel=${{ secrets.SLACK_CHANNEL_ID }}&oldest=$oldest&limit=50" \
            > slack_response.json
          
          # レスポンスをチェック
          if [ "$(jq -r '.ok' slack_response.json)" = "true" ]; then
            echo "Slack API call successful"
            
            # 新しいメッセージをフィルタリング（ボットメッセージと処理済みを除外）
            FILTERED_MESSAGES=$(jq -c '[.messages[] | select(.bot_id == null and (.reactions // [] | any(.name == "white_check_mark") | not))]' slack_response.json)
            
            # メッセージが存在するかチェック
            if [ "$FILTERED_MESSAGES" != "[]" ] && [ "$FILTERED_MESSAGES" != "null" ]; then
              echo "Found new messages to process"
              echo "has_messages=true" >> $GITHUB_OUTPUT
              echo "messages=$FILTERED_MESSAGES" >> $GITHUB_OUTPUT
              echo "Messages output: $FILTERED_MESSAGES"
            else
              echo "No new messages found"
              echo "has_messages=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "Slack API Error: $(jq -r '.error' slack_response.json)"
            exit 1
          fi

      - name: Process Messages with Gemini
        if: steps.slack.outputs.has_messages == 'true'
        id: gemini_process
        run: |
          echo "Processing messages with Gemini API..."
          
          # Slackメッセージを取得
          MESSAGES='${{ steps.slack.outputs.messages }}'
          echo "Messages to process: $MESSAGES"
          
          # 各メッセージを処理して複数のIssueを作成
          # while loopの代わりにsubshellを使用して、各メッセージを個別に処理
          for i in $(seq 0 $(($(echo "$MESSAGES" | jq length) - 1))); do
            msg=$(echo "$MESSAGES" | jq -r ".[$i]")
            msg_text=$(echo "$msg" | jq -r '.text')
            msg_ts=$(echo "$msg" | jq -r '.ts')
            msg_user=$(echo "$msg" | jq -r '.user')
            
            echo "Processing message $((i+1)): $msg_text"
            
            # メッセージテキストをエスケープ
            ESCAPED_MSG=$(echo "$msg_text" | sed 's/"/\\"/g' | sed 's/\\/\\\\/g' | tr '\n' ' ')
            
            # Gemini APIでメッセージを整形（構造化出力使用）
            GEMINI_RESPONSE=$(curl -s -X POST \
              -H "x-goog-api-key: ${{ secrets.GEMINI_API_KEY }}" \
              -H "Content-Type: application/json" \
              -d "{
                \"contents\": [{
                  \"parts\": [{
                    \"text\": \"以下のSlackメッセージをGitHub Issue用のタイトルと本文に整形してください。雑談や質問の場合はshould_create_issueをfalseにしてください。また、内容の緊急度・重要度に応じて優先度を設定してください。\\n\\nSlackメッセージ: $ESCAPED_MSG\"
                  }]
                }],
                \"generationConfig\": {
                  \"responseMimeType\": \"application/json\",
                  \"responseSchema\": {
                    \"type\": \"OBJECT\",
                    \"properties\": {
                      \"title\": {
                        \"type\": \"STRING\",
                        \"description\": \"明確で具体的なタイトル\"
                      },
                      \"body\": {
                        \"type\": \"STRING\", 
                        \"description\": \"構造化された説明\"
                      },
                      \"should_create_issue\": {
                        \"type\": \"BOOLEAN\",
                        \"description\": \"Issueを作成するかどうか\"
                      },
                      \"priority\": {
                        \"type\": \"STRING\",
                        \"enum\": [\"low\", \"medium\", \"high\", \"urgent\"],
                        \"description\": \"優先度: low(低), medium(中), high(高), urgent(緊急)\"
                      }
                    },
                    \"required\": [\"title\", \"body\", \"should_create_issue\", \"priority\"]
                  }
                }
              }" \
              "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent")
            
            if [ $? -eq 0 ]; then
              echo "Gemini API call successful for message $((i+1))"
              echo "Raw response: $GEMINI_RESPONSE"
              
              # 構造化出力から直接JSONを解析
              GEMINI_JSON=$(echo "$GEMINI_RESPONSE" | jq -r '.candidates[0].content.parts[0].text')
              echo "Gemini structured output: $GEMINI_JSON"
              
              # Issueを作成するかチェック
              if echo "$GEMINI_JSON" | jq -e '.should_create_issue' >/dev/null 2>&1; then
                SHOULD_CREATE=$(echo "$GEMINI_JSON" | jq -r '.should_create_issue')
                if [ "$SHOULD_CREATE" = "true" ]; then
                  ISSUE_TITLE=$(echo "$GEMINI_JSON" | jq -r '.title')
                  ISSUE_BODY=$(echo "$GEMINI_JSON" | jq -r '.body')
                  ISSUE_PRIORITY=$(echo "$GEMINI_JSON" | jq -r '.priority')
                  
                  echo "Will create issue with title: $ISSUE_TITLE (Priority: $ISSUE_PRIORITY)"
                  
                  # 個別のIssue作成のため、出力変数は使用せず、直接API呼び出し
                  echo "issue_data_$i<<EOF" >> $GITHUB_OUTPUT
                  echo "{\"title\": \"$ISSUE_TITLE\", \"body\": \"$ISSUE_BODY\", \"priority\": \"$ISSUE_PRIORITY\", \"user\": \"$msg_user\", \"ts\": \"$msg_ts\"}" >> $GITHUB_OUTPUT
                  echo "EOF" >> $GITHUB_OUTPUT
                  echo "should_create_issue_$i=true" >> $GITHUB_OUTPUT
                else
                  echo "Skipping issue creation for message $((i+1)) - determined to be casual conversation"
                fi
              else
                echo "Error: Could not parse Gemini structured output as JSON for message $((i+1))"
              fi
            else
              echo "Error: Gemini API call failed for message $((i+1))"
            fi
          done
          
          # 最初の有効なメッセージのフラグを設定
          if [ -f "$GITHUB_OUTPUT" ] && grep -q "should_create_issue_0=true" "$GITHUB_OUTPUT"; then
            echo "should_create_issue=true" >> $GITHUB_OUTPUT
          fi

      - name: Create Priority Labels
        if: steps.gemini_process.outputs.should_create_issue == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
          script: |
            // 優先度ラベルを事前作成（既存の場合はスキップ）
            const priorityLabels = [
              { name: 'Priority: Low', color: 'f1bc31', description: '低優先度のIssue' },
              { name: 'Priority: Medium', color: 'e88a1a', description: '中優先度のIssue' },
              { name: 'Priority: High', color: 'b22222', description: '高優先度のIssue' },
              { name: 'Priority: Critical', color: '7c0a02', description: '緊急対応が必要なIssue' }
            ];
            
            for (const label of priorityLabels) {
              try {
                await github.rest.issues.createLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: label.name,
                  color: label.color,
                  description: label.description
                });
                console.log(`Created label: ${label.name}`);
              } catch (error) {
                if (error.status === 422) {
                  console.log(`Label already exists: ${label.name}`);
                } else {
                  console.error(`Error creating label ${label.name}:`, error.message);
                }
              }
            }
            
            // from-slackとauto-createdラベルも作成
            const additionalLabels = [
              { name: 'from-slack', color: '4a154b', description: 'Slackから自動作成されたIssue' },
              { name: 'auto-created', color: '0366d6', description: '自動作成されたIssue' }
            ];
            
            for (const label of additionalLabels) {
              try {
                await github.rest.issues.createLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: label.name,
                  color: label.color,
                  description: label.description
                });
                console.log(`Created label: ${label.name}`);
              } catch (error) {
                if (error.status === 422) {
                  console.log(`Label already exists: ${label.name}`);
                } else {
                  console.error(`Error creating label ${label.name}:`, error.message);
                }
              }
            }

      - name: Create GitHub Issues
        if: steps.gemini_process.outputs.should_create_issue == 'true'
        uses: actions/github-script@v7
        env:
          should_create_issue_0: ${{ steps.gemini_process.outputs.should_create_issue_0 }}
          should_create_issue_1: ${{ steps.gemini_process.outputs.should_create_issue_1 }}
          should_create_issue_2: ${{ steps.gemini_process.outputs.should_create_issue_2 }}
          should_create_issue_3: ${{ steps.gemini_process.outputs.should_create_issue_3 }}
          should_create_issue_4: ${{ steps.gemini_process.outputs.should_create_issue_4 }}
          issue_data_0: ${{ steps.gemini_process.outputs.issue_data_0 }}
          issue_data_1: ${{ steps.gemini_process.outputs.issue_data_1 }}
          issue_data_2: ${{ steps.gemini_process.outputs.issue_data_2 }}
          issue_data_3: ${{ steps.gemini_process.outputs.issue_data_3 }}
          issue_data_4: ${{ steps.gemini_process.outputs.issue_data_4 }}
        with:
          github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
          script: |
            // 優先度に応じたラベルを設定（一般的な命名規則に従う）
            const priorityLabels = {
              'urgent': ['Priority: Critical', 'from-slack', 'auto-created'],
              'high': ['Priority: High', 'from-slack', 'auto-created'],
              'medium': ['Priority: Medium', 'from-slack', 'auto-created'],
              'low': ['Priority: Low', 'from-slack', 'auto-created']
            };
            
            const createdIssues = [];
            
            // 各メッセージ用のissue_dataを処理
            for (let i = 0; i < 5; i++) { // 最大5個のメッセージまで処理
              const shouldCreate = process.env[`should_create_issue_${i}`];
              if (shouldCreate === 'true') {
                const issueDataStr = process.env[`issue_data_${i}`];
                if (issueDataStr) {
                  const issueData = JSON.parse(issueDataStr);
                  
                  const labels = priorityLabels[issueData.priority] || ['from-slack', 'auto-created'];
                  
                  console.log(`Creating issue ${i+1}: ${issueData.title}`);
                  
                  const issue = await github.rest.issues.create({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    title: issueData.title,
                    body: `**優先度**: ${issueData.priority.toUpperCase()}\n\n${issueData.body}\n\n---\n*Originally posted in Slack by user ${issueData.user}*`,
                    labels: labels
                  });
                  
                  console.log(`Created issue #${issue.data.number}: ${issue.data.html_url}`);
                  
                  // 作成されたIssueに@claudeメンションのコメントを投稿
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.data.number,
                    body: `@claude このIssue #${issue.data.number} を解決してください。\n\n以下の内容に基づいて、具体的な実装方針と必要なコード変更を提案してください：\n\n**タイトル**: ${issueData.title}\n\n**説明**:\n${issueData.body}\n\n**優先度**: ${issueData.priority}`
                  });
                  
                  console.log(`Posted @claude comment to issue #${issue.data.number}`);
                  createdIssues.push({
                    number: issue.data.number,
                    url: issue.data.html_url
                  });
                }
              }
            }
            
            console.log(`Created ${createdIssues.length} issues total`);
            if (createdIssues.length > 0) {
              core.setOutput('issue_numbers', createdIssues.map(i => i.number).join(','));
              core.setOutput('issue_urls', createdIssues.map(i => i.url).join(','));
            }

      - name: Mark Messages as Processed
        if: steps.slack.outputs.has_messages == 'true'
        run: |
          # 処理済みメッセージにリアクションを追加
          echo "Processing messages for reactions..."
          echo '${{ steps.slack.outputs.messages }}' | jq -r '.[] | .ts' | while read ts; do
            if [ -n "$ts" ]; then
              echo "Adding reaction to message: $ts"
              RESPONSE=$(curl -s -X POST \
                -H "Authorization: Bearer ${{ secrets.SLACK_BOT_TOKEN }}" \
                -H "Content-Type: application/json" \
                -d "{\"channel\": \"${{ secrets.SLACK_CHANNEL_ID }}\", \"timestamp\": \"$ts\", \"name\": \"white_check_mark\"}" \
                https://slack.com/api/reactions.add)
              
              # レスポンスをチェック
              if [ "$(echo "$RESPONSE" | jq -r '.ok')" = "true" ]; then
                echo "Successfully added reaction to $ts"
              else
                echo "Failed to add reaction to $ts: $(echo "$RESPONSE" | jq -r '.error')"
              fi
            fi
          done